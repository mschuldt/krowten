                                     GRADER

Name of student running submit: Michael Schuldt
Login of student running submit: cs61b-ayn

Second team member's name: Yalun Rao
Second team member's login: cs61b-aum

Third team member's name: Michelle Chen 
Third team member's login: cs61b-axx

IMPORTANT:  Once you've submitted Project 2 once, the same team member should
submit always.  If a different teammate must submit, inform cs61b@cory.eecs of
all the details.  Include a complete list of team members, and let us know
which submission you want graded.

If you've submitted your project once, or even written a substantial amount of
code together, you may not change partners without the permission of the
instructor.
===============================================================================
Does your program compile without errors?


Have you tested your program on the 61B lab machines?


Did you successfully implement game tree search?  Did you successfully
implement alpha-beta pruning?  Are there any limitations on it?  What is the
default number of search levels set by the one-parameter MachinePlayer
constructor (or is it a variable-depth search)?


Describe your board evaluation function in some detail.


Does your MachinePlayer use any special method of choosing the first few moves?


Is there anything else the graders should know to help them read your project?



Describe the classes, modules, and interfaces you designed before and while you
implemented the project.  Your description should include:
  -  A list of the classes your program uses.
  -  A list of each of the "modules" used in or by MachinePlayer, similar to
     the list in the "Teamwork" section of the README (but hopefully more
     detailed).  (If you're using a list class, that should probably count as
     a separate module.)
  -  For each module, list the class(es) the module is implemented in.
  -  For each module, say which of your team members implemented it.
  -  For each module, describe its interface--specifically, the prototype and
     behavior of each method that is available for external callers (outside
     the module) to call.  Don't include methods that are only meant to be
     called from within the module.

     For each method, provide (1) a method prototype and (2) a complete,
     unambiguous description of the behavior of the method/module.  This
     description should also appear before the method in your code's comments.

You will probably need to change some of your design decisions as you go; be
sure to modify this file to reflect these changes before you submit your
project.  Your design of classes and interfaces will be worth 10% of your
grade.



/** Board.Board(int) constructs a new board for player with color COLOR
*  The board is initially empty
*
*  COLOR must be white or black (1 or 0)
*
*  @param color an integer representing the color of the player
*         who 'owns' this board. 1 for white and 0 for black.
*/
public Board(int color)



/** Board.move() moves a piece on the board as described
*  by MOVE. The piece moved belongs to the owner of this board,
*  that is, the player whose color is Board.color
*
*  Unusual conditions:
*    * If MOVE is not an illegal move, the behavior of this method
*      is not defined.
*
* @param move describes the type of move to make
*/
public void move(Move move)



/** Board.opponentMove() moves a piece on the board as described
*  by MOVE. The piece moved belongs to the opponent of the owner
*  of this board, that is, the player whose color is Board.opponentColor
*
*  Unusual conditions:
*    * If MOVE is not an illegal move, the behavior of this method
*      is not defined.
*
* @param move describes the type of move to make
*/
public void opponentMove(Move move)



/** Board.unMove(Move) reverses the effects of the move MOVE.
*  MOVE must have been a move for the pieces of the player
*  who owns this board, that is, the player whose color
*  was passed to the initializer.
*
*  Unusual conditions:
*  The behaviour of this method is not defined for the case
*  in which MOVE is invalid or is intended for the opponent.
*
*  @param move the move to reverse.
*/
void unMove(Move move)



/** Board.adjacentPieces(int,int) returns an array of pieces
* that are adjacent to the pieces at coordinates (X,Y) on
* the board.
*
* The x,y coordinates are indexed from the top left with x
* increasing to the right and y increasing down.
*
*  If there is no piece at (x,y) but (x,y) is still a valid
*  board location, then this method works as expected.
*
* The list returned does not include PIECE, just the ones around it,
* so the returned list ranges in length from 0 to 8.

* Unusual conditions:
*  if (x,y) is not a valid location on the board, then this
*  method will likely cause the program to crash.
*  The behavior in this case is undefined (but the corner
*  pieces are ok).
*
*  @param x the x-coordinate location of the square
*  @param y the y-coordinate location of the square
*
*  @returns an PieceList of pieces adjacent to location (x,y) on the board
*/


/** Board.adjacentPieces(Piece) returns a PieceList of pieces
* that are adjacent to PIECE on the board
*
* The list returned does not include PIECE, just the ones around it,
* so the returned list ranges in length from 0 to 8.
*
* Unusual conditions:
*  The behavior of this method is undefined if piece is not
*  actually on the board.
*
*  @param piece a piece on the board whose adjacent pieces will be returned
*
*  @returns an array of pieces adjacent to PIECE on the board
*/
public PieceList adjacentPieces(int x, int y)


/** Board.pieceAt(int,int) returns true if a piece is located
* at square (X,Y) on this board, else false.
*
*  if (x,y) is not a valid coordinate on this board, return false
*
* @param x the x-coordinate of the square to check
* @param y the y-coordinate of the square to check
*
* @returns boolean; true if a piece is located at (X,Y), elsefalse
*/
public boolean pieceAt(int x, int y)



/** Board.getPiece(int,int) returns the piece located at (X,Y)
*  on this board.
*
*  Unusual conditions:
*   If (x,y) is not a valid coordinate on board, then the
*   behavior of this method is undefined (and may likely
*   crash the program)
*
* @param x the x-coordinate of the piece to be returned
* @param y the y-coordinate of the piece to be returned
*
* @returns the piece located at (X,Y) on this board.
*/
public Piece getPiece(int x, int y)



/** Board.connectedPieces(int, int) returns a list of all the pieces
*   'connected' the the piece located at square (X,Y) on this board.
*   The exact rules for connectedness are as defined in this projects
*   readme file.
*
*   If there is no piece at (X,Y) return null
*
*   Unusual conditions:
*    -If (X,Y) does not describe a valid location on the board, the
*     behavior of this program is undefined. It may return a list
*     of pieces or it may crash the program.
*
* @param x the x-coordinate of the piece on the board
* @param y the y-coordinate of the piece on the board
*
* @returns an array of pieces that are 'connected' to the one at (X,Y)
*/
public PieceList connectedPieces(int x, int y)



/** Board.connectedPieces(Piece) returns a list of all the pieces
*   'connected' the piece PIECE.
*
*   Unusual conditions:
*    If PIECE is not on this board then the behavior of this method
*    is undefined.
*
* @param piece the piece on whose connected pieces will be returned

* @returns an array of pieces that are 'connected' to PIECE
*/
public PieceList connectedPieces(Piece piece){



/**
*  Board.hasNetwork() determines whether "this" Board has a valid
*  network for player whose color is Board.color.
*
*  Unusual conditions:
*  If the board contain illegal squares, the behavior of this
*        method is undefined.
*
*  @return true if player whose color is 'this.color' has a winning network
*          on 'this' GameBoard; false otherwise.
**/
public boolean hasNetwork()


/**
* Board.getNumPieces(int) returns the number of pieces
* of COLOR on the board
*/
public int getNumPieces(int color){

/** Board.hash() returns the hash of the current board.
*  Explanation:
*   The number 1073741789 is the largest prime that fits in half
*   of a java 'long'. It is used to shrink the size of the bitboards
*   so that they can both fit in a 'long' without overlapping.
*   They are combined by shifting one of the boards left and ORing
*   them together.
*/
public long hash(){

/*
* of all valid Moves, preform a minimax tree search and return the Move
* which gives the Player the highest chance of winning.
*/
  public Move chooseMove();


/*
* returns list of all valid moves available, meaning
* 1) move placing a new piece if he has < 10 pieces on the board and moving a piece otherwise
* 2) the location where the piece will be placed is a valid and legal location on the board 
* (i.e., it is actually on the board, is not one of the four corners, and is not the other player's goals)
* and is not currently occupied by any piece including itself.
* 3) there will not be any clusters >= 3 on the board after making the Move.
*/


/*
* returns true if Player P making Move M on Board B will result in a cluster of 3 or more pieces.
*/
  boolean formsIllegalCluster(Move M, int color);


/*
* evaluates Player P's pieces the current board and returns an estimated score based 
*on current networks and goals, a higher score denoting a larger chance of winning the game.
*/
  int scoreBoard(Board B, Player P);


/*
* makes Move m on this board for the opponent's piece, and returns true if successful.
*/
  public boolean opponentMove(Move m);


/*
* makes Move m on this board and returns true if successful.
*/
  public boolean forceMove(Move m);

                             ______________

                              MODULE-NOTES

                             ______________


Table of Contents
_________________

list of modules
interfaces organized by class
.. Piece
..... fields
.. M: Board
..... constructor
..... move a piece
..... move an opponents piece
..... unmove a piece
..... get adjacent pieces
..... get connected pieces
..... does a square contain a piece?
..... get a the piece at a location
..... M: network finder
..... M: determining whether a move is valid
..... M: determining whether a move will result in the formation of a cluster >= 3
.. MachinePlayer
..... M: performing minimax tree search
..... M: generating a list of all valid moves
..... M: board evaluation function
..... move opponents piece
..... force a move


each method that is part of a separate module is marked with 'M:'

everything in the board is one module except for the network finder


list of modules
===============

  1. board representation (Michael)
  2. performing minimax tree search (Michelle)
  3. generating a list of all valid moves (Helen)
  4. determining whether a move is valid (Helen)
  5. cluster detection (Michelle)
  6. network finder (Michael)
  7. board evaluation function (Shared..for now)


interfaces organized by class
=============================

Piece
~~~~~

fields
------

  int color int x int y


M: Board
~~~~~~~~

constructor
-----------
/*
* constructs a Board of color C.
*/
  public Board(color C);


move a piece
------------
/*
* makes the Move M for this Player.
*/
  void move(Move M);


move an opponents piece
-----------------------
/*
* makes the move M for the opposing Player.
* (how come this is void while the one in board evaluation returns bool? 0.0)
*/
  void opponentMove(Move M);


unmove a piece
--------------
/*
* (assumes no new moves have been made after M and) undoes Move M.
*/
  void unMove(Move M);


get adjacent pieces
-------------------
/*
* returns list of the 8 adjacent pieces by Piece P at (x, y) in the order
* {nw, n, ne, w, e, sw, s, se}. 
*/
  PieceList adjacentPieces(int x, int y); PieceList adjacentPieces(Piece P);


get connected pieces
--------------------
/*
* returns array of the 8 pieces connected to Piece P at (x, y) in the order 
* {nw, n, ne, w, e, sw, s, se}. 
*/
  PieceList connectedPieces(Piece P); PieceList connectedPieces(int x, int y);


does a square contain a piece?
------------------------------
/*
* returns true if position (x, y) contains a piece.
* (throws InvalidLocationException?)
*/
  boolean pieceAt(int x, int y);


get a the piece at a location
-----------------------------
/*
* returns Piece p on position (x, y) on the board.
*/
  Piece getPiece(int x, int y);


M: network finder
-----------------
/*
* returns true if Player P currently has at least one network of six or more pieces currently on the board.
*/
  boolean hasNetwork(Player P);
  
  
  M: determining whether a move is valid
--------------------------------------
/*
* returns true if and only if Player P can legally make Move M on Board B, meaning
* 1) P is placing a new piece if he has < 10 pieces on the board and moving a piece otherwise
* 2) the location where the piece will be placed is a valid and legal location on the board 
* (i.e., it is actually on the board, is not one of the four corners, and is not the other player's goals)
* and is not currently occupied by any piece including itself.
* 3) there will not be any clusters >= 3 on the board after making the Move.
*/
  boolean isValidMove(Move M, int Color);


M: determining whether a move will result in the formation of a cluster >= 3
----------------------------------------------------------------------------
/*
* returns true if Player P making Move M on Board B will result in a cluster of 3 or more pieces.
*/
  boolean formsIllegalCluster(Move M, int Color);



MachinePlayer
~~~~~~~~~~~~~

M: performing minimax tree search
---------------------------------
/*
* of all valid Moves, preform a minimax tree search and return the Move
* which gives the Player the highest chance of winning.
*/
  public Move chooseMove();


M: generating a list of all valid moves
---------------------------------------
/*
* for current Board B, returns an array of all valid Moves available to Player P.
*/
  Move[] validMoves(Board B, Player P);




M: board evaluation function
----------------------------
/*
* evaluates Player P's pieces the current board and returns an estimated score based 
*on current networks and goals, a higher score denoting a larger chance of winning the game.
*/
  int scoreBoard(Board B, Player P);


move opponents piece
--------------------
/*
* makes Move m on this board for the opponent's piece, and returns true if successful.
*/
  public boolean opponentMove(Move m);


force a move
------------
/*
* makes Move m on this board and returns true if successful.
*/
  public boolean forceMove(Move m);
